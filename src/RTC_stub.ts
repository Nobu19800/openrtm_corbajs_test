// This file is generated by the corba.js IDL compiler from 'RTC.idl'.

import { ORB, Stub } from 'corba.js'
import * as valuetype from "./RTC_valuetype"
import * as _interface from "./RTC"

export namespace RTC {

class ComponentActionBase extends Stub implements _interface.RTC.ComponentAction {
    async on_initialize(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_initialize", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async on_finalize(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_finalize", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async on_startup(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_startup", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_shutdown(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_shutdown", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_activated(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_activated", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_deactivated(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_deactivated", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_aborting(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_aborting", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_error(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_error", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_reset(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_reset", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
}

class LightweightRTObjectBase extends ComponentActionBase implements _interface.RTC.LightweightRTObject {
    async initialize(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "initialize", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async finalize(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "finalize", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async is_alive(exec_context: _interface.RTC.ExecutionContext): Promise<boolean> {
        return await this.orb.twowayCall(this, "is_alive", (encoder) => {
            encoder.object(exec_context)
        },
        (decoder) => decoder.bool())
    }
    async exit(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "exit", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async attach_context(exec_context: _interface.RTC.ExecutionContext): Promise<number> {
        return await this.orb.twowayCall(this, "attach_context", (encoder) => {
            encoder.object(exec_context)
        },
        (decoder) => decoder.long())
    }
    async detach_context(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "detach_context", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async get_context(exec_handle: number): Promise<_interface.RTC.ExecutionContext> {
        return await this.orb.twowayCall(this, "get_context", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.object())
    }
    async get_owned_contexts(): Promise<Array<_interface.RTC.ExecutionContext>> {
        return await this.orb.twowayCall(this, "get_owned_contexts", (encoder) => {
        },
        (decoder) => decoder.sequence(() => decoder.object()))
    }
    async get_participating_contexts(): Promise<Array<_interface.RTC.ExecutionContext>> {
        return await this.orb.twowayCall(this, "get_participating_contexts", (encoder) => {
        },
        (decoder) => decoder.sequence(() => decoder.object()))
    }
    async get_context_handle(cxt: _interface.RTC.ExecutionContext): Promise<number> {
        return await this.orb.twowayCall(this, "get_context_handle", (encoder) => {
            encoder.object(cxt)
        },
        (decoder) => decoder.long())
    }
}

export class LightweightRTObject extends LightweightRTObjectBase {
    static _idlClassName(): string {
        return "omg.org/RTC/LightweightRTObject"
    }

    static narrow(object: any): RTC.LightweightRTObject {
        if (object instanceof RTC.LightweightRTObject)
            return object as RTC.LightweightRTObject
        throw Error("RTC.LightweightRTObject.narrow() failed")
    }

}


export class ComponentAction extends ComponentActionBase {
    static _idlClassName(): string {
        return "omg.org/RTC/ComponentAction"
    }

    static narrow(object: any): RTC.ComponentAction {
        if (object instanceof RTC.ComponentAction)
            return object as RTC.ComponentAction
        throw Error("RTC.ComponentAction.narrow() failed")
    }
}

class DataFlowComponentActionBase extends Stub implements _interface.RTC.DataFlowComponentAction {
    async on_execute(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_execute", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_state_update(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_state_update", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_rate_changed(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_rate_changed", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
}

export class DataFlowComponentAction extends DataFlowComponentActionBase {
    static _idlClassName(): string {
        return "omg.org/RTC/DataFlowComponentAction"
    }

    static narrow(object: any): RTC.DataFlowComponentAction {
        if (object instanceof RTC.DataFlowComponentAction)
            return object as RTC.DataFlowComponentAction
        throw Error("RTC.DataFlowComponentAction.narrow() failed")
    }

}

class DataFlowComponentBase extends LightweightRTObjectBase implements _interface.RTC.DataFlowComponent {
    async on_execute(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_execute", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_state_update(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_state_update", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
    async on_rate_changed(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_rate_changed", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
}

export class DataFlowComponent extends DataFlowComponentBase {
    static _idlClassName(): string {
        return "omg.org/RTC/DataFlowComponent"
    }

    static narrow(object: any): RTC.DataFlowComponent {
        if (object instanceof RTC.DataFlowComponent)
            return object as RTC.DataFlowComponent
        throw Error("RTC.DataFlowComponent.narrow() failed")
    }

}

export class Fsm extends LightweightRTObjectBase implements _interface.RTC.Fsm {
    static _idlClassName(): string {
        return "omg.org/RTC/Fsm"
    }

    static narrow(object: any): RTC.Fsm {
        if (object instanceof RTC.Fsm)
            return object as RTC.Fsm
        throw Error("RTC.Fsm.narrow() failed")
    }

}

export class FsmParticipantAction extends Stub implements _interface.RTC.FsmParticipantAction {
    static _idlClassName(): string {
        return "omg.org/RTC/FsmParticipantAction"
    }

    static narrow(object: any): RTC.FsmParticipantAction {
        if (object instanceof RTC.FsmParticipantAction)
            return object as RTC.FsmParticipantAction
        throw Error("RTC.FsmParticipantAction.narrow() failed")
    }

    async on_action(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_action", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }
}

export class FsmParticipant extends LightweightRTObjectBase implements _interface.RTC.FsmParticipant {
    static _idlClassName(): string {
        return "omg.org/RTC/FsmParticipant"
    }

    static narrow(object: any): RTC.FsmParticipant {
        if (object instanceof RTC.FsmParticipant)
            return object as RTC.FsmParticipant
        throw Error("RTC.FsmParticipant.narrow() failed")
    }

    async on_action(exec_handle: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "on_action", (encoder) => {
            encoder.long(exec_handle)
        },
        (decoder) => decoder.ulong())
    }

}

class RTObjectBase extends LightweightRTObjectBase implements _interface.RTC.RTObject {
    async get_component_profile(): Promise<valuetype.RTC.ComponentProfile> {
        return await this.orb.twowayCall(this, "get_component_profile", (encoder) => {
        },
        (decoder) => decoder.value("omg.org/RTC/ComponentProfile"))
    }
    async get_ports(): Promise<Array<_interface.RTC.PortService>> {
        return await this.orb.twowayCall(this, "get_ports", (encoder) => {
        },
        (decoder) => decoder.sequence(() => decoder.object()))
    }
}

export class RTObject extends RTObjectBase {
    static _idlClassName(): string {
        return "omg.org/RTC/RTObject"
    }

    static narrow(object: any): RTC.RTObject {
        if (object instanceof RTC.RTObject)
            return object as RTC.RTObject
        throw Error("RTC.RTObject.narrow() failed")
    }

}

export class DataFlowComponent_aist extends DataFlowComponentBase implements _interface.RTC.DataFlowComponent_aist {
    static _idlClassName(): string {
        return "openrtm.aist.go.jp/OpenRTM/DataFlowComponent"
    }

    static narrow(object: any): RTC.DataFlowComponent_aist {
        if (object instanceof RTC.DataFlowComponent_aist)
            return object as RTC.DataFlowComponent_aist
        throw Error("RTC.DataFlowComponent_aist.narrow() failed")
    }
    async get_component_profile(): Promise<valuetype.RTC.ComponentProfile> {
        return await this.orb.twowayCall(this, "get_component_profile", (encoder) => {
        },
        (decoder) => decoder.value("omg.org/RTC/ComponentProfile"))
    }
    async get_ports(): Promise<Array<_interface.RTC.PortService>> {
        return await this.orb.twowayCall(this, "get_ports", (encoder) => {
        },
        (decoder) => decoder.sequence(() => decoder.object()))
    }

}

class ExecutionContextBase extends Stub implements _interface.RTC.ExecutionContext {
    async is_running(): Promise<boolean> {
        return await this.orb.twowayCall(this, "is_running", (encoder) => {
        },
        (decoder) => decoder.bool())
    }
    async start(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "start", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async stop(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "stop", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async get_rate(): Promise<number> {
        return await this.orb.twowayCall(this, "get_rate", (encoder) => {
        },
        (decoder) => decoder.double())
    }
    async set_rate(rate: number): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "set_rate", (encoder) => {
            encoder.double(rate)
        },
        (decoder) => decoder.ulong())
    }
    async add_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "add_component", (encoder) => {
            encoder.object(comp)
        },
        (decoder) => decoder.ulong())
    }
    async remove_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "remove_component", (encoder) => {
            encoder.object(comp)
        },
        (decoder) => decoder.ulong())
    }
    async activate_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "activate_component", (encoder) => {
            encoder.object(comp)
        },
        (decoder) => decoder.ulong())
    }
    async deactivate_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "deactivate_component", (encoder) => {
            encoder.object(comp)
        },
        (decoder) => decoder.ulong())
    }
    async reset_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "reset_component", (encoder) => {
            encoder.object(comp)
        },
        (decoder) => decoder.ulong())
    }
    async get_component_state(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.LifeCycleState> {
        return await this.orb.twowayCall(this, "get_component_state", (encoder) => {
            encoder.object(comp)
        },
        (decoder) => decoder.ulong())
    }
    async get_kind(): Promise<_interface.RTC.ExecutionKind> {
        return await this.orb.twowayCall(this, "get_kind", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
}

export class ExecutionContext extends ExecutionContextBase {
    static _idlClassName(): string {
        return "omg.org/RTC/ExecutionContext"
    }

    static narrow(object: any): RTC.ExecutionContext {
        if (object instanceof RTC.ExecutionContext)
            return object as RTC.ExecutionContext
        throw Error("RTC.ExecutionContext.narrow() failed")
    }

}

export class PortService extends Stub implements _interface.RTC.PortService {
    static _idlClassName(): string {
        return "omg.org/RTC/PortService"
    }

    static narrow(object: any): RTC.PortService {
        if (object instanceof RTC.PortService)
            return object as RTC.PortService
        throw Error("RTC.PortService.narrow() failed")
    }

    async get_port_profile(): Promise<valuetype.RTC.PortProfile> {
        return await this.orb.twowayCall(this, "get_port_profile", (encoder) => {
        },
        (decoder) => decoder.value("omg.org/RTC/PortProfile"))
    }
    async get_connector_profiles(): Promise<Array<valuetype.RTC.ConnectorProfile>> {
        return await this.orb.twowayCall(this, "get_connector_profiles", (encoder) => {
        },
        (decoder) => decoder.sequence(() => decoder.value("ConnectorProfile")))
    }
    async get_connector_profile(connector_id: string): Promise<valuetype.RTC.ConnectorProfile> {
        return await this.orb.twowayCall(this, "get_connector_profile", (encoder) => {
            encoder.string(connector_id)
        },
        (decoder) => decoder.value("omg.org/RTC/ConnectorProfile"))
    }
    async connect(connector_profile: valuetype.RTC.ConnectorProfile): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "connect", (encoder) => {
            encoder.value(connector_profile)
        },
        (decoder) => decoder.ulong())
    }
    async disconnect(connector_id: string): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "disconnect", (encoder) => {
            encoder.string(connector_id)
        },
        (decoder) => decoder.ulong())
    }
    async disconnect_all(): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "disconnect_all", (encoder) => {
        },
        (decoder) => decoder.ulong())
    }
    async notify_connect(connector_profile: valuetype.RTC.ConnectorProfile): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "notify_connect", (encoder) => {
            encoder.value(connector_profile)
        },
        (decoder) => decoder.ulong())
    }
    async notify_disconnect(connector_id: string): Promise<_interface.RTC.ReturnCode_t> {
        return await this.orb.twowayCall(this, "notify_disconnect", (encoder) => {
            encoder.string(connector_id)
        },
        (decoder) => decoder.ulong())
    }
}

export class ExecutionContextService extends ExecutionContextBase implements _interface.RTC.ExecutionContextService {
    static _idlClassName(): string {
        return "omg.org/RTC/ExecutionContextService"
    }

    static narrow(object: any): RTC.ExecutionContextService {
        if (object instanceof RTC.ExecutionContextService)
            return object as RTC.ExecutionContextService
        throw Error("RTC.ExecutionContextService.narrow() failed")
    }

    async get_profile(): Promise<valuetype.RTC.ExecutionContextProfile> {
        return await this.orb.twowayCall(this, "get_profile", (encoder) => {
        },
        (decoder) => decoder.value("omg.org/RTC/ExecutionContextProfile"))
    }
}

} // namespace RTC

