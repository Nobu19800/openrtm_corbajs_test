// This file is generated by the corba.js IDL compiler from 'RTC.idl'.

import { ORB, Skeleton, GIOPEncoder, GIOPDecoder } from 'corba.js'
import * as valuetype from "./RTC_valuetype"
import * as _interface from "./RTC"

export namespace RTC{

abstract class ComponentActionBase extends Skeleton implements _interface.RTC.ComponentAction {
    constructor(orb: ORB) { super(orb) }

    abstract on_initialize(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_initialize(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_initialize()
        encoder.ulong(result)
    }
    abstract on_finalize(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_finalize(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_finalize()
        encoder.ulong(result)
    }
    abstract on_startup(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_startup(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_startup(decoder.long())
        encoder.ulong(result)
    }
    abstract on_shutdown(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_shutdown(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_shutdown(decoder.long())
        encoder.ulong(result)
    }
    abstract on_activated(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_activated(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_activated(decoder.long())
        encoder.ulong(result)
    }
    abstract on_deactivated(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_deactivated(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_deactivated(decoder.long())
        encoder.ulong(result)
    }
    abstract on_aborting(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_aborting(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_aborting(decoder.long())
        encoder.ulong(result)
    }
    abstract on_error(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_error(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_error(decoder.long())
        encoder.ulong(result)
    }
    abstract on_reset(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_reset(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_reset(decoder.long())
        encoder.ulong(result)
    }
}

abstract class LightweightRTObjectBase extends ComponentActionBase implements _interface.RTC.LightweightRTObject {
    constructor(orb: ORB) { super(orb) }

    abstract initialize(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_initialize(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.initialize()
        encoder.ulong(result)
    }
    abstract finalize(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_finalize(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.finalize()
        encoder.ulong(result)
    }
    abstract is_alive(exec_context: _interface.RTC.ExecutionContext): Promise<boolean>
    private async _orb_is_alive(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.is_alive(decoder.object())
        encoder.bool(result)
    }
    abstract exit(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_exit(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.exit()
        encoder.ulong(result)
    }
    abstract attach_context(exec_context: _interface.RTC.ExecutionContext): Promise<number>
    private async _orb_attach_context(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.attach_context(decoder.object())
        encoder.long(result)
    }
    abstract detach_context(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_detach_context(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.detach_context(decoder.long())
        encoder.ulong(result)
    }
    abstract get_context(exec_handle: number): Promise<_interface.RTC.ExecutionContext>
    private async _orb_get_context(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_context(decoder.long())
        encoder.object(result)
    }
    abstract get_owned_contexts(): Promise<Array<_interface.RTC.ExecutionContext>>
    private async _orb_get_owned_contexts(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_owned_contexts()
        encoder.sequence(result, (item) => encoder.object(item))
    }
    abstract get_participating_contexts(): Promise<Array<_interface.RTC.ExecutionContext>>
    private async _orb_get_participating_contexts(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_participating_contexts()
        encoder.sequence(result, (item) => encoder.object(item))
    }
    abstract get_context_handle(cxt: _interface.RTC.ExecutionContext): Promise<number>
    private async _orb_get_context_handle(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_context_handle(decoder.object())
        encoder.long(result)
    }
}

export abstract class LightweightRTObject extends LightweightRTObjectBase {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/LightweightRTObject"
    }
}

export abstract class ComponentAction extends ComponentActionBase {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/ComponentAction"
    }
}

abstract class DataFlowComponentActionBase extends Skeleton implements _interface.RTC.DataFlowComponentAction {
    constructor(orb: ORB) { super(orb) }
    abstract on_execute(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_execute(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_execute(decoder.long())
        encoder.ulong(result)
    }
    abstract on_state_update(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_state_update(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_state_update(decoder.long())
        encoder.ulong(result)
    }
    abstract on_rate_changed(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_rate_changed(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_rate_changed(decoder.long())
        encoder.ulong(result)
    }
}

export abstract class DataFlowComponentAction extends DataFlowComponentActionBase implements _interface.RTC.DataFlowComponentAction {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/DataFlowComponentAction"
    }

}

abstract class DataFlowComponentBase extends LightweightRTObjectBase implements _interface.RTC.DataFlowComponent {
    constructor(orb: ORB) { super(orb) }
    abstract on_execute(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_execute(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_execute(decoder.long())
        encoder.ulong(result)
    }
    abstract on_state_update(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_state_update(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_state_update(decoder.long())
        encoder.ulong(result)
    }
    abstract on_rate_changed(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_rate_changed(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_rate_changed(decoder.long())
        encoder.ulong(result)
    }
}

export abstract class DataFlowComponent extends DataFlowComponentBase {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/DataFlowComponent"
    }

}

export abstract class Fsm extends LightweightRTObjectBase implements _interface.RTC.Fsm {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/Fsm"
    }

}

export abstract class FsmParticipantAction extends Skeleton implements _interface.RTC.FsmParticipantAction {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/FsmParticipantAction"
    }

    abstract on_action(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_action(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_action(decoder.long())
        encoder.ulong(result)
    }
}

export abstract class FsmParticipant extends LightweightRTObjectBase implements _interface.RTC.FsmParticipant {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/FsmParticipant"
    }

    abstract on_action(exec_handle: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_on_action(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.on_action(decoder.long())
        encoder.ulong(result)
    }

}

abstract class RTObjectBase extends LightweightRTObjectBase implements _interface.RTC.RTObject {
    constructor(orb: ORB) { super(orb) }
    abstract get_component_profile(): Promise<valuetype.RTC.ComponentProfile>
    private async _orb_get_component_profile(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_component_profile()
        encoder.value(result)
    }
    abstract get_ports(): Promise<Array<_interface.RTC.PortService>>
    private async _orb_get_ports(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_ports()
        encoder.sequence(result, (item) => encoder.object(item))
    }
}

export abstract class RTObject extends RTObjectBase {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/RTObject"
    }

}

export abstract class DataFlowComponent_aist extends DataFlowComponentBase implements _interface.RTC.DataFlowComponent_aist {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "openrtm.aist.go.jp/OpenRTM/DataFlowComponent"
    }
    abstract get_component_profile(): Promise<valuetype.RTC.ComponentProfile>
    private async _orb_get_component_profile(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_component_profile()
        encoder.value(result)
    }
    abstract get_ports(): Promise<Array<_interface.RTC.PortService>>
    private async _orb_get_ports(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_ports()
        encoder.sequence(result, (item) => encoder.object(item))
    }
}

abstract class ExecutionContextBase extends Skeleton implements _interface.RTC.ExecutionContext {
    constructor(orb: ORB) { super(orb) }
    abstract is_running(): Promise<boolean>
    private async _orb_is_running(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.is_running()
        encoder.bool(result)
    }
    abstract start(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_start(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.start()
        encoder.ulong(result)
    }
    abstract stop(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_stop(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.stop()
        encoder.ulong(result)
    }
    abstract get_rate(): Promise<number>
    private async _orb_get_rate(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_rate()
        encoder.double(result)
    }
    abstract set_rate(rate: number): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_set_rate(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.set_rate(decoder.double())
        encoder.ulong(result)
    }
    abstract add_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_add_component(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.add_component(decoder.object())
        encoder.ulong(result)
    }
    abstract remove_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_remove_component(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.remove_component(decoder.object())
        encoder.ulong(result)
    }
    abstract activate_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_activate_component(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.activate_component(decoder.object())
        encoder.ulong(result)
    }
    abstract deactivate_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_deactivate_component(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.deactivate_component(decoder.object())
        encoder.ulong(result)
    }
    abstract reset_component(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_reset_component(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.reset_component(decoder.object())
        encoder.ulong(result)
    }
    abstract get_component_state(comp: _interface.RTC.LightweightRTObject): Promise<_interface.RTC.LifeCycleState>
    private async _orb_get_component_state(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_component_state(decoder.object())
        encoder.ulong(result)
    }
    abstract get_kind(): Promise<_interface.RTC.ExecutionKind>
    private async _orb_get_kind(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_kind()
        encoder.ulong(result)
    }
}

export abstract class ExecutionContext extends ExecutionContextBase implements _interface.RTC.ExecutionContext {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/ExecutionContext"
    }

}

export abstract class PortService extends Skeleton implements _interface.RTC.PortService {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/PortService"
    }

    abstract get_port_profile(): Promise<valuetype.RTC.PortProfile>
    private async _orb_get_port_profile(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_port_profile()
        encoder.value(result)
    }
    abstract get_connector_profiles(): Promise<Array<valuetype.RTC.ConnectorProfile>>
    private async _orb_get_connector_profiles(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_connector_profiles()
        encoder.sequence(result, (item) => encoder.value(item))
    }
    abstract get_connector_profile(connector_id: string): Promise<valuetype.RTC.ConnectorProfile>
    private async _orb_get_connector_profile(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_connector_profile(decoder.string())
        encoder.value(result)
    }
    abstract connect(connector_profile: valuetype.RTC.ConnectorProfile): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_connect(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.connect(decoder.value("omg.org/RTC/ConnectorProfile"))
        encoder.ulong(result)
    }
    abstract disconnect(connector_id: string): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_disconnect(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.disconnect(decoder.string())
        encoder.ulong(result)
    }
    abstract disconnect_all(): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_disconnect_all(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.disconnect_all()
        encoder.ulong(result)
    }
    abstract notify_connect(connector_profile: valuetype.RTC.ConnectorProfile): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_notify_connect(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.notify_connect(decoder.value("omg.org/RTC/ConnectorProfile"))
        encoder.ulong(result)
    }
    abstract notify_disconnect(connector_id: string): Promise<_interface.RTC.ReturnCode_t>
    private async _orb_notify_disconnect(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.notify_disconnect(decoder.string())
        encoder.ulong(result)
    }
}

export abstract class ExecutionContextService extends ExecutionContextBase implements _interface.RTC.ExecutionContextService {
    constructor(orb: ORB) { super(orb) }
    static _idlClassName(): string {
        return "omg.org/RTC/ExecutionContextService"
    }

    abstract get_profile(): Promise<valuetype.RTC.ExecutionContextProfile>
    private async _orb_get_profile(decoder: GIOPDecoder, encoder: GIOPEncoder) {
        const result = await this.get_profile()
        encoder.value(result)
    }
}

} // namespace RTC

